%  PT Parser.ssl        Ver. 4.2
%
% Date:  30 Jun 1980
%        (Revised v4.2 - 18 Dec 2019)
%
% Author:  Alan Rosselet
%
% Abstract
%
%     This module parses the syntax token stream emitted by the scanner
%   and emits hello a postfix stream of tokens to the semantic analyzer
%   module.  The parser detects and repairs syntax errors so that the
%   token stream emitted to the semantic analyzer is syntactically
%   legal (except for the special case of declaration phase errors - see
%   comment in the Block routine below).

Input :
        % Keywords must be first both here and in stdIdentifiers,
        % and they must appear in the exact same order

        % changes start
        pPub                    'pub'
        firstKeywordToken = pPub
        pMod                    'mod'
        pMain                   'main'
        pLet                    'let'
        pMut                    'mut'
        pFn                     'fn'
        pLoop                   'loop'
        pBreak                  'break'
        pMatch                  'match'
        % changes end

        pElse                   'else'
        pOf                     'of'    
        pFile                   'file'
        pConst                  'const'
        pType                   'type'
        pIf                     'if'
        pWhile                  'while'
        lastKeywordToken = pWhile % changed from pRepeat 

        % Scanner tokens -
        %   These are the tokens actually recognized by the Scanner itself.

        % Compound tokens - 
        %   These will be sent to the parser with a value or index.
        pIdentifier 
        firstCompoundInputToken = pIdentifier
        pInteger
        pStringLiteral
        lastCompoundInputToken = pStringLiteral

        % Non-compound tokens - 
        %   These tokens simply represent themselves.
        pNewLine
        pEndFile
        pPlus                   '+'
        pMinus                  '-'
        pStar                   '*'
        pColonEquals            ':='
        % change: remove pDot 
        pComma                  ','
        pSemicolon              ';'
        pColon                  ':'
        pEquals                 '='
        pNotEqual               '!='
        pLess                   '<'
        pLessEqual              '<='
        pGreaterEqual           '>='
        pGreater                '>'
        pLeftParen              '('
        pRightParen             ')'
        pLeftBracket            '['
        pRightBracket           ']'
        % change: removed pDotDot

        % changes start
        pLeftBrace              '{'
        pRightBrace             '}'
        pQuestionMark           '?'
        pSlash                  '/'
        pPercent                '%'                    
        pAmpersand              '&'   
        pOrBar                  '|'
        pExclamation            '!'       
        pUnderscore             '_'
        pDoubleAmpersand        '&&'           
        pDoubleOrBar            '||'           
        pDoubleEquals           '=='        
        pEqualsGreater          '=>'        
        pPlusEquals             '+='   
        pMinusEquals            '-='        
        lastSyntaxToken = pMinusEquals;                 

        % changes end

Output :
        sIdentifier 
        firstSemanticToken = sIdentifier
        firstCompoundSemanticToken = sIdentifier
        sInteger
        sStringLiteral
        lastCompoundSemanticToken = sStringLiteral

        % change: these should be copied from parser.def 

        sProgram
        sParmBegin
        sParmEnd
        sConst
        sType
        sVar

        sProcedure
        sBegin
        sEnd
        sNegate
        sArray
        sFile
        sRange
        sCaseStmt
        sCaseEnd
        sLabelEnd
        sExpnEnd
        sNullStmt
        sAssignmentStmt
        sSubscript
        sCallStmt
        sFieldWidth
        sIfStmt
        sThen
        sElseIf
        sElse
        sWhileStmt
         
        % change begin
        sLoopStmt
        sLoopBreakIf
        sLoopEnd
        sModule
        sPublic
        sCaseOtherwise
        sSubstring
        sLength
        sMutable
        sInitialValue
        % change end

        sEq
        sNE
        sLT
        sLE
        sGT
        sGE
        sAdd
        sSubtract
        sMultiply
        sDivide
        sModulus
        sInfixOr
        sOr
        sInfixAnd
        sAnd
        sNot
        sNewLine
        sEndOfFile
        lastSemanticToken = sEndOfFile;


rules

Mod:
        'mod' 
        [
                | 'main':
                @Program
        ]
        ;

Program :
% change: removed check for 'main'
        .sProgram
        % program name
        % pIdentifier
        % program parameters
        '('
        {
            pIdentifier  .sIdentifier
            [
                | ',':
                | *:
                    >
            ]
        }
        ')'
        .sParmEnd
        @Block  
        ; 
        % remove ; and . from end of program

%move handling of braces to their respective functions
Block :
        % Strictly speaking, standard Pascal requires that declarations
        % appear only in the order consts, types, vars, procedures.
        % We allow arbitrary intermixing of these instead to preserve
        % programmer sanity.
        {[
            | '{' :
                    @BeginStmt
            
            | 'const':
                .sConst
                @ConstantDefinitions
            
            | 'type':
                .sType
                @TypeDefinitions 

            | 'let':
                .sVar
                @VariableDeclarations

            % change: added for public function - is there a better way?   
            | 'pub' :
                .sProcedure
                % procedure name
                pIdentifier .sIdentifier
                .sPublic
                @FnHeading
                @Block

            | 'fn' :
                .sProcedure
                % procedure name
                pIdentifier .sIdentifier
                @FnHeading
                @Block

            % change: added mod to emit mod and then go into Block
            % does anything else need to be done???     
            | 'mod' :
                .sModule
                pIdentifier .sIdentifier
                @Block

            % change : alternatives from the statement rule
            | pIdentifier:
                @AssignmentOrCallStmt
            | 'if':
                @IfStmt
            | 'while':
                @WhileStmt
            | 'loop':
                @Loop
            | 'match':
                @MatchStmt
            | 'break':
                .sLoopBreakIf
                @Expression
            | *:
                >

        ]};

AssignmentOrCallStmt :
        [
            | '=':
                .sAssignmentStmt
                .sIdentifier    % identifier accepted in the Statement rule
                @Expression
                .sExpnEnd
            | '[':
                .sAssignmentStmt
                .sIdentifier
                .sSubscript
                @Expression
                .sExpnEnd
                ']'  ':='
                @Expression
                .sExpnEnd
            | *:
                @CallStmt
        ];

% change: call block rule, and add support for sElseIf token
IfStmt :
        .sIfStmt
        @Expression
        .sExpnEnd
        .sThen
        @Block 
        {[
            | 'else':
                [
                    | 'if':
                        .sElseIf
                        @Expression
                        .sExpnEnd
                        .sThen
                        @Block
                    | *:
                        .sElse
                        @Block
                ]
            | *:
            >
        ]};

WhileStmt :
        .sWhileStmt
        @Expression
        .sExpnEnd
        @Block;

FnHeading :
        % Accept zero or more procedure formal parameter declarations.
        '('
        {   [
                | 'mut' :
                    .sVar
                    pIdentifier
                    .sIdentifier
                | pIdentifier :
                    .sIdentifier
                | *:
                >
            ]
        ':'
            % type identifier
            pIdentifier  .sIdentifier
            [
                | ',':
                | *:
                    >
            ] 
        }
        ')'
        .sParmEnd;


BeginStmt :
        .sBegin
        {
            @Block
            [
                | ';':
                | '}':
                    .sEnd
                    >
            ]
        };

CallStmt :
        .sCallStmt
        .sIdentifier    % procedure identifier accepted in the Statement rule
        % Accept zero or more actual parameters
        '('
        {   [
                | 'mut' :
                    .sVar
                    @Expression
                    .sExpnEnd
                | ')':
                    .sParmEnd
                    >
                | * :
                    @Expression
                    .sExpnEnd 
            ]

            % check if more params
            [
                | ',':
                | *:
                .sParmEnd
                ')'
                >
            ] 
        };

ConstantDefinitions :
        % Accept one or more named constant definitions
        pIdentifier  .sIdentifier
        '=' @ConstantValue 
        {[
            | ';' :
                >
            | ',' :
                @ConstantDefinitions 
            | *:
                >
        ]};

ConstantValue :
        [
            | pInteger:
                .sInteger
            | pIdentifier:
                .sIdentifier
            | '-':
                @UnsignedIntegerConstant
                .sNegate
            | '+':
                @UnsignedIntegerConstant
            | pStringLiteral:
                .sStringLiteral
        ];

UnsignedIntegerConstant :
[
        | pIdentifier:
        .sIdentifier
        | pInteger:
        .sInteger
];

TypeDefinitions :
        % Accept one or more named type definitions.
        pIdentifier  .sIdentifier
        '='  @TypeBody  ';'
;

TypeBody :
        [
            | 'file':
                .sFile
                'of'  @SimpleType
            | *:
                @SimpleType
        ];

SimpleType :
        % A simple type is a named type (possibly predefined)
        % or a subrange type specification
        [
            | '[':
                .sArray
                pIdentifier
                .sIdentifier
                ':'
                .sRange         %% this may be unnecessary
                [
                    | pInteger :
                        @OptionallySignedIntegerConstant
                    | pIdentifier :
                        .sIdentifier
                ]
                ']'
            | pIdentifier :
                .sIdentifier
        ];

OptionallySignedIntegerConstant :
        [
            | '-':
                @UnsignedIntegerConstant
                .sNegate
            | '+':
                @UnsignedIntegerConstant
            | *:
                @UnsignedIntegerConstant
        ];

VariableDeclarations :
        % Accept one or more variable declarations.
        [
            | 'mut' :
                @Mutable
            | pIdentifier :
                .sIdentifier
                {[
                    | ':' : 
                        @TypeBody
                        [
                            | '=' :
                              .sInitialValue
                              @Factor
                              @Expression
                             .sExpnEnd
                             | * :
                        ]
                    | '=' :
                        .sInitialValue
                        @Factor
                        @Expression
                        .sExpnEnd
                    | ',' :
                        @VariableDeclarations 
                    | ';':
                        >
                    | * :
                        >
                ]}
        ];

Mutable:
        pIdentifier
        .sIdentifier
        {[
            | ':' :
                 @TypeBody
            | '=' :
                .sInitialValue
                @Factor
                @Expression
                .sExpnEnd
            | ';' :
                >
            | ',' :
                @Mutable 
            | *:
                >
        ]}
.sMutable
;

% change TODO: add ==, and others??
Expression :
        @SimpleExpression
        [
            | '==':
                %change to '=='
                @SimpleExpression  .sEq
                %need to change to ! for not equals
            | '!=':
                @SimpleExpression  .sNE
            | '<':
                @SimpleExpression  .sLT
            | '<=':
                @SimpleExpression  .sLE
            | '>':
                @SimpleExpression  .sGT
            | '>=':
                @SimpleExpression  .sGE
            | *:
        ];

SimpleExpression :
        [
            | '+':
                @Term
            | '-':
                @Term  .sNegate
            % change - remove comma  
            | *:
                @Term
        ]
        {[
            | '+':
                @Term  .sAdd
            | '-':
                @Term  .sSubtract
            | '|':
                .sInfixOr  @Term  .sOr
            | *:
                >
        ]};

Term :
        @Factor
        {[
            | '*':
                @Factor  .sMultiply
            | '/':
                @Factor  .sDivide
            | '%':
                @Factor  .sModulus
            | '&':
                .sInfixAnd  @Factor  .sAnd
            | *:
                >
        ]};

Factor :
        [
            | pIdentifier:
                .sIdentifier
                @IdentifierExtension
            | pInteger:
                .sInteger
            | '(':
                @Expression  ')'
            | '!':
                @Factor
                .sNot
            | pStringLiteral:
                .sStringLiteral
            | 'file':
                .sFile '(' @Expression ')'
                .sExpnEnd
            | * :
        ];

IdentifierExtension :
        % Handle subscripts and function actual parameter lists
        [
            | '[':
                .sSubscript
                @Expression  ']'
                .sExpnEnd
            | '(':
                .sParmBegin
                @Expression  ')'
                .sExpnEnd
                .sParmEnd
            | *:
        ];

MatchStmt :
        .sCaseStmt
        %do we have to look for one?
        @Expression
        .sExpnEnd
        '{'
        {[
            | '|':
            [
                | '_':
                >
                | *:

            ]
                @MatchAlternative
            | *:
                >
        ]}
        '=>'
        .sCaseOtherwise
        @Block
        .sCaseEnd
        '}';

%more than one label?
MatchAlternative :
    % A case alternative is a statement labelled by
    % one or more optionally signed integer constants
        {
            @OptionallySignedIntegerConstant
            [
                | '|':
                | *:
                    >
            ]
        }
        .sLabelEnd
        '=>'  @Block;

Loop:
    .sLoopStmt
    @BeginStmt
    .sEnd

    @Expression
    .sExpnEnd;

end

